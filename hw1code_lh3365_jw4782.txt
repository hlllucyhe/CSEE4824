#######################################
#             Question 1              #
#######################################
#define _GNU_SOURCE
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <x86intrin.h>   // for _mm_clflush, __rdtscp (same as asm)

// Reduced REPEAT for quicker testing, especially for large memory sizes
#ifndef REPEAT
#define REPEAT 10000
#endif
#define WARMUP 10
#define CACHELINE 64
#define PAGE 4096

static inline void clflush_range(void *p, size_t len) {
    uintptr_t addr = (uintptr_t)p;
    uintptr_t end  = addr + len;
    for (; addr < end; addr += CACHELINE) {
        _mm_clflush((void*)addr);
    }
    _mm_mfence();  // ensure flush completion
}

static inline uint64_t tsc_begin(void) {
    unsigned int aux;
    _mm_lfence();                // serialize before reading TSC
    return __rdtscp(&aux);       // read tsc with ordering
}

static inline uint64_t tsc_end(void) {
    unsigned int aux;
    uint64_t t = __rdtscp(&aux); // read tsc with ordering
    _mm_lfence();         // serialize after reading TSC
    return t;
}

static inline void prefault_touch(char *buf, size_t bytes) {
    // Page pre-touch to avoid page faults/zeroing during timing
    for (size_t i = 0; i < bytes; i += PAGE) buf[i] = 1;
    if (bytes > 0) buf[bytes-1] ^= 0; // touch last byte to prevent OOB
}

static inline void memtest(size_t bytes, FILE *out) {
    // 64B aligned allocation (to avoid false sharing across cache lines)
    char *src, *dst;
    if (posix_memalign((void**)&src, CACHELINE, bytes) ||
        posix_memalign((void**)&dst, CACHELINE, bytes)) {
        perror("posix_memalign"); exit(1);
    }

    // Initialize & pre-touch pages
    memset(src, 0xA5, bytes);
    memset(dst, 0,    bytes);
    prefault_touch(src, bytes);
    prefault_touch(dst, bytes);

    // Warmup: establish i-cache path/page tables/TLBs etc., not timed
    for (int r = 0; r < WARMUP; ++r) {
        clflush_range(src, bytes);
        clflush_range(dst, bytes);
        (void)memcpy(dst, src, bytes);
    }

    // Start actual measurement
    for (int r = 0; r < REPEAT; ++r) {
        // flush all cache lines that will be touched this iteration
        clflush_range(src, bytes);
        clflush_range(dst, bytes);

        uint64_t t0 = tsc_begin();
        memcpy(dst, src, bytes);
        uint64_t t1 = tsc_end();

        // prevent compiler optimizing away memcpy
        asm volatile("" :: "r"(dst[0]) : "memory");

        // record results to CSV
        fprintf(out, "%zu,%" PRIu64 "\n", bytes, (t1 - t0));
    }

    free(src);
    free(dst);
}

int main(void) {
    FILE *out = fopen("results.csv", "w");
    if (!out) { perror("fopen"); return 1; }
    fprintf(out, "Size(Bytes),Time(Ticks)\n");

    // iterate over sizes from 2^6 to 2^21
    const int exps[] = {6,7,8,9,10,11,12,13,14,15,16,20,21};
    for (size_t i = 0; i < sizeof(exps)/sizeof(exps[0]); ++i) {
        size_t bytes = (size_t)1 << exps[i];
        memtest(bytes, out);
    }
    fclose(out);
    return 0;
}

#######################################
#                 Python              #
#######################################
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('results.csv')

# plot average time vs size
avg_times = df.groupby("Size(Bytes)")["Time(Ticks)"].mean().reset_index()
plt.figure(figsize=(12, 8))
sns.lineplot(data=avg_times, x='Size(Bytes)', y='Time(Ticks)', marker='o')
plt.xscale("log", base=2)
plt.yscale("log", base=10)
plt.title("Figure 1. Average memcpy time vs data size")
plt.xlabel("Size (Bytes)")
plt.ylabel("Average Time (ticks)")
plt.grid(True)
plt.show()

# box plot
plt.figure(figsize=(12, 12))
sns.boxplot(data=df, x='Size(Bytes)', y='Time(Ticks)')
plt.yscale("log")
plt.title("Figure 2. Box plot of memcpy time for different data sizes")
plt.xlabel("Size (Bytes)")
plt.ylabel("Time (ticks)")
plt.show()

# histograms
for size, size_df in df.groupby("Size(Bytes)"):
  # filtering outliers
  low = size_df["Time(Ticks)"].quantile(0.00)
  high = size_df["Time(Ticks)"].quantile(0.99)
  size_df = size_df[(size_df["Time(Ticks)"] >= low) & (size_df["Time(Ticks)"] <= high)]
  plt.figure(figsize=(10, 6))
  sns.histplot(data=size_df, x='Time(Ticks)', bins=100, kde=True)
  plt.title("Distributions of memcpy time for size {} Bytes".format(size))
  plt.xlabel("Time (ticks)")
  plt.ylabel("Count")
  plt.show()

#######################################
#             Question 3              #
#######################################
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

#define REPEAT 100
#define BUFFER_SIZE (64 * 1024 * 1024) // 64MB to ensure we're accessing DRAM
#define STRIDE_SIZE (8 * 1024) // 8KB stride, typical DRAM row size

inline void clflush(volatile void *p) {
    asm volatile ("clflush (%0)" :: "r"(p));
}

inline uint64_t rdtsc() {
    unsigned long a, d;
    asm volatile ("rdtsc" : "=a" (a), "=d" (d));
    return a | ((uint64_t)d << 32);
}

inline void memory(void *dst, void *src, size_t n) {
    memcpy(dst, src, n);
}

long int rep;

void test_open_vs_closed_row() {
    // Allocate large buffers using mmap to ensure we are working in DRAM
    char* buffer1 = (char*) mmap(NULL, BUFFER_SIZE, PROT_READ | PROT_WRITE, 
                                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    char* buffer2 = (char*) mmap(NULL, BUFFER_SIZE, PROT_READ | PROT_WRITE, 
                                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    if (buffer1 == MAP_FAILED || buffer2 == MAP_FAILED) {
        printf("Memory allocation failed\n");
        return;
    }
    
    // Initialize buffers
    for (int i = 0; i < BUFFER_SIZE; i++) {
        buffer1[i] = (char)(i % 256);
        buffer2[i] = 0;
    }
    
    uint64_t start, end;
    uint64_t time_first_access, time_second_access, time_third_access;
    
    volatile char *addr1 = buffer1;
    volatile char *addr2 = buffer1 + STRIDE_SIZE; // Different row
    
    // Flush both addresses
    clflush(addr1);
    clflush(addr2);

    // First access to row 1
    start = rdtsc();
    *addr1 = 'C';
    end = rdtsc();
    time_first_access = end - start;
    printf("First access to row 1: %llu ticks\n", time_first_access);
    
    // Flush both addresses
    clflush(addr1);
    clflush(addr2);

    // Access to different row2
    start = rdtsc();
    *addr2 = 'D';
    end = rdtsc();
    time_second_access = end - start;
    printf("First access to row2: %llu ticks\n", time_second_access);

    // Flush both addresses
    clflush(addr1);
    clflush(addr2);

    // Access to same row2
    start = rdtsc();
    *addr2 = 'D';
    end = rdtsc();
    time_third_access = end - start;
    printf("Second access to row2: %llu ticks\n", time_third_access);

    // Clean up
    munmap(buffer1, BUFFER_SIZE);
    munmap(buffer2, BUFFER_SIZE);
}
    

int main(int ac, char **av) {
    printf("Testing DRAM Row Buffer Policy\n");
    printf("==============================\n");
    
    test_open_vs_closed_row();
    return 0;
}